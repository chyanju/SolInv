import numpy as np
import pandas as pd
from collections import namedtuple

from .composer import Composer
# from ..spec import Interval
from ..spec.interval import *

class Padding():
    '''
    A special class to represent pending keystroke
    '''
    def __init__(self):
        pass

    def __str__(self):
        return "<PAD>"

    def __repr__(self):
        return "<PAD>"

class KSMorpheusRCComposer(Composer):
    '''
    A composer that mimics user input step by step, row wise.
    This can also be used to infer additional partial information (for validation/invalidation of speculative specification)
    when there's no ground truth provided (by only calling the `infer` function).
    '''
    def __init__(self, table=None):
        # table takes the form of the standard benchmark, which is:
        # {"columns": [...], "data": [...]}
        # note: the composer class doesn't check the validity of the table
        table0 = None
        if isinstance(table, pd.DataFrame):
            table0 = {
                "columns": table.columns.tolist(),
                "data": table.to_numpy().tolist(),
            }
        else:
            table0 = table

        self._table = table0
        self._columns = table0["columns"]
        self._data = table0["data"]
        self._n0 = len(table0["columns"])
        tmp_data = np.asarray(table0["data"])
        self._nr, self._nc = tmp_data.shape
        assert self._n0 == self._nc, "Header length should match column length, got {} and {}.".format(self._n0, self._nc)
        self._ntot = self._n0 + self._nr * self._nc

    def make_empty_table(self):
        return {
            "columns": [Padding() for _ in range(self._n0)],
            "data": [
                [Padding() for j in range(self._nc)]
                for i in range(self._nr)
            ]
        }

    def compose(self, ts):
        if ts>=self._ntot:
            # no more keystroke
            return None

        tmp_table = self.make_empty_table()
        # fill in table until up to ts-th keystroke
        tmp_r = int((ts+1)/self._nc)+1 # total row
        tmp_c = (ts+1)%self._nc # columns in last row
        # print("tmp_r={}, tmp_c={}".format(tmp_r, tmp_c))
        for i in range(tmp_r):
            if i==tmp_r-1:
                # last row, use tmp_c
                for j in range(tmp_c):
                    if i==0:
                        tmp_table["columns"][j] = self._table["columns"][j]
                    else:
                        tmp_table["data"][i-1][j] = self._table["data"][i-1][j]
            else:
                # not the last row, use self._nc
                for j in range(self._nc):
                    if i==0:
                        tmp_table["columns"][j] = self._table["columns"][j]
                    else:
                        tmp_table["data"][i-1][j] = self._table["data"][i-1][j]
        return tmp_table

    def infer_masks(self, table, format_set=False):
        # infer additional information for the synthesizer, usually this includes masks.
        # note: only accepts concrete table or partial table generated by the same composer
        # fixme: only infer rows and cols
        # detect the currently maximum rows, and cols
        tmp_maxrow = -1
        tmp_maxcol = -1
        for i in range(len(table["columns"])):
            if not isinstance(table["columns"][i], Padding):
                # has something
                tmp_maxcol = max( i+1, tmp_maxcol )
        for i in range(len(table["data"])):
            for j in range(len(table["data"][i])):
                if not isinstance(table["data"][i][j], Padding):
                    # has something, this row holds
                    tmp_maxrow = max( i+1, tmp_maxrow )
                    tmp_maxcol = max( j+1, tmp_maxcol )

        ret = {
            "row": Interval(IMIN, IMAX) if tmp_maxrow==-1 else Interval(tmp_maxrow, IMAX), # >= tmp_maxrow, since the user can add more
            "col": Interval(IMIN, IMAX) if tmp_maxcol==-1 else Interval(tmp_maxcol, IMAX), # >= tmp_maxcol, since the user can add more
            "head": Interval(IMIN, IMAX),
            "content": Interval(IMIN, IMAX),
        }
        if format_set:
            # turn interval into sets
            return { dkey: interval_to_set(ret[dkey]) for dkey in ret.keys() }
        else:
            return ret
        # return {
        #     "row": set([x for x in range(IMIN, IMAX)]) if tmp_maxrow==-1 else set([x for x in range(tmp_maxrow, IMAX)]), # >= tmp_maxrow, since the user can add more
        #     "col": set([x for x in range(IMIN, IMAX)]) if tmp_maxcol==-1 else set([x for x in range(tmp_maxcol, IMAX)]), # >= tmp_maxcol, since the user can add more
        #     "head": set([x for x in range(IMIN, IMAX)]),
        #     "content": set([x for x in range(IMIN, IMAX)]),
        # }

